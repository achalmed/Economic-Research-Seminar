\section*{ANEXO A: CÓDIGOS EN PYTHON}
\phantomsection
\addcontentsline{toc}{section}{ANEXO A: CÓDIGOS EN PYTHON}
A continuación nosotros  presentamos el anexo abc se presentan los códigos desarrollados en \textit{Python}. En este sentido, el \autoref{Algoritmo1} muestra el algoritmo usado para edificaciones con aislamiento de base con comportamiento bilineal. El \autoref{Algoritmo2} muestra las funciones usadas por los algoritmos anteriormente mencionados.

\vspace*{2mm}

*ANEXO 1.1

\subsection*{Respuesta Sísmica de una Edificación con AS}
%\phantomsubsection
\addcontentsline{toc}{subsection}{Respuesta Sísmica de una Edificación con AS}

\begin{MyFont}
\begin{adjustwidth}{4.8mm}{}
\begin{lstlisting}[language=Python, caption= {\footnotesize Edificación con aislamiento sísmico bilineal}, mathescape=true,label={Algoritmo1}]
# REPUESTA SÍSMICA DE UNA EDIFICACIÓN DE n NIVELES CON AS
import Funciones_KS as fun
import numpy as np
from scipy  import linalg as LA
import copy

# PROPIEDADES DINÁMICAS
# Parámetros dinámicos de la Superestructura
n=3                 # N° de Pisos
gdl=n+1             # GDL = N° de Pisos+1
Tnf=0.3             # Periodo base fija, [s]
$\xi$=5           			 # Amortiguamiento, [%]
$\lambda$=(gdl-1)/gdl 			 # Relación de masas

# Parámetros dinámicos de la interfaz de aislamiento
r=0.1               # Razón de rigideces Kp/Ke
Q=105          		  # Fuerza característica normalizada, [cm/s^2]
K2=30         		  # Rigidez postfluencia normalizada, [1/s^2]

# LECTURA DEL REGISTRO SÍSMICO
ug=np.genfromtxt("./Sismo_Lima66NS.txt")  #[cm/s^2]
$\Delta$t=0.002; N=len(ug)
t=[i*$\Delta$t for i in range(N)]

\end{lstlisting}
\end{adjustwidth}
\end{MyFont}

*ANEXO 1.2

\subsection*{Funciones}
%\phantomsubsection
\addcontentsline{toc}{subsection}{Funciones}

\begin{MyFont}
\begin{adjustwidth}{4.8mm}{}
\begin{lstlisting}[language=Python, caption={\footnotesize Funciones-KS}, mathescape=true,label={Algoritmo2}]
import numpy as np
from scipy  import linalg as LA
import copy

# FUNCIÓN EIGEN
def eigen(Tsf=1,n=5):
    Z=np.identity(n); ke=(4*n/Tsf)**2; k=np.zeros(n)
    for i in range(n):
        if i==0:
            k[i]=2*ke
        else:
            k[i]=ke
    K=tridiag(k,n); M=np.identity(n)
    vp,$\varphi$p=LA.eigh(K,M); $\varphi$p=$\varphi$p.T; FP=[]; MP=[] 
    for i in range(n):
        FP.append(sum($\varphi$p[i].T@M))
    for i in range(n):
        MP.append((sum($\varphi$p[i].T@M))**2)
    T=2*np.pi/(vp)**0.5; MMP=MP/sum(MP)
    return T,$\varphi$p,FP,MMP

\end{lstlisting}
\end{adjustwidth}
\end{MyFont}

